import React, { useRef, useEffect, useState, useCallback } from 'react';
import * as THREE from 'three';

const NeonDriftGame = () => {
  const mountRef = useRef(null);
  const gameRef = useRef({
    scene: null,
    camera: null,
    renderer: null,
    player: null,
    obstacles: [],
    collectibles: [],
    gameSpeed: 0.5, // –ù–∞—á–∏–Ω–∞–µ–º —Å –±–æ–ª—å—à–µ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
    playerLane: 1,
    isJumping: false,
    jumpHeight: 0,
    jumpVelocity: 0,
    score: 0,
    distance: 0,
    gameRunning: false,
    spawnTimer: 0,
    keys: {},
    lastTime: 0,
    powerUps: [],
    activePowerUp: null,
    powerUpTimer: 0,
    smokeParticles: null
  });

  const [gameState, setGameState] = useState({
    score: 0,
    distance: 0,
    speed: 5.0, // –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å 5x
    gameStarted: false,
    gameOver: false,
    paused: false,
    showMenu: true,
    showLeaderboard: false,
    playerName: '',
    nameEntered: false,
    activePowerUp: null,
    powerUpTimeLeft: 0
  });

  const [leaderboard, setLeaderboard] = useState([]);

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º sessionStorage –≤–º–µ—Å—Ç–æ localStorage –¥–ª—è –ª—É—á—à–µ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
  useEffect(() => {
    try {
      const savedLeaderboard = sessionStorage.getItem('neonDriftLeaderboard');
      if (savedLeaderboard) {
        setLeaderboard(JSON.parse(savedLeaderboard));
      }
    } catch (e) {
      console.log('Storage not available, using memory only');
    }
  }, []);

  const saveScore = (name, score, distance) => {
    const newLeaderboard = [...leaderboard];
    const existingPlayerIndex = newLeaderboard.findIndex(player => player.name === name);
    
    if (existingPlayerIndex !== -1) {
      if (score > newLeaderboard[existingPlayerIndex].score) {
        newLeaderboard[existingPlayerIndex] = { name, score, distance, date: new Date().toLocaleDateString() };
      }
    } else {
      newLeaderboard.push({ name, score, distance, date: new Date().toLocaleDateString() });
    }
    
    newLeaderboard.sort((a, b) => b.score - a.score);
    const topLeaderboard = newLeaderboard.slice(0, 10);
    
    setLeaderboard(topLeaderboard);
    try {
      sessionStorage.setItem('neonDriftLeaderboard', JSON.stringify(topLeaderboard));
    } catch (e) {
      console.log('Could not save to storage');
    }
  };

  const initThreeJS = useCallback(() => {
    const game = gameRef.current;
    
    game.scene = new THREE.Scene();
    game.scene.fog = new THREE.Fog(0x000000, 30, 150);
    
    game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    game.camera.position.set(0, 6, 10);
    game.camera.lookAt(0, 0, 0);
    
    game.renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      powerPreference: "high-performance"
    });
    game.renderer.setSize(window.innerWidth, window.innerHeight);
    game.renderer.setClearColor(0x000000);
    game.renderer.shadowMap.enabled = true;
    game.renderer.shadowMap.type = THREE.PCFShadowMap;
    game.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    
    if (mountRef.current) {
      mountRef.current.appendChild(game.renderer.domElement);
    }
    
    // –û—Å–≤–µ—â–µ–Ω–∏–µ
    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
    game.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0x8A2BE2, 1.5);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    game.scene.add(directionalLight);
    
    // –ò–≥—Ä–æ–∫
    const playerGeometry = new THREE.SphereGeometry(0.5, 16, 16); // –£–º–µ–Ω—å—à–∏–ª–∏ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—é
    const playerMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x8A2BE2,
      emissive: 0x4B0082,
      shininess: 100
    });
    game.player = new THREE.Mesh(playerGeometry, playerMaterial);
    game.player.position.set(0, 1, 8);
    game.player.castShadow = true;
    game.scene.add(game.player);
    
    createTrack();
    createOptimizedParticles();
    
  }, []);

  const createTrack = () => {
    const game = gameRef.current;
    
    // –¢—Ä–∞—Å—Å–∞ —Å –Ω–µ–æ–Ω–æ–≤—ã–º–∏ –ª–∏–Ω–∏—è–º–∏
    for (let i = 0; i < 3; i++) {
      const laneGeometry = new THREE.PlaneGeometry(2.5, 200);
      const laneMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x1a1a2e,
        transparent: true,
        opacity: 0.7 
      });
      const lane = new THREE.Mesh(laneGeometry, laneMaterial);
      lane.rotation.x = -Math.PI / 2;
      lane.position.set((i - 1) * 3, 0, -90);
      lane.receiveShadow = true;
      game.scene.add(lane);
      
      // –ù–µ–æ–Ω–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
      const borderGeometry = new THREE.BoxGeometry(0.1, 0.3, 200);
      const borderMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x00FFFF,
        emissive: 0x008888 
      });
      
      const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
      leftBorder.position.set((i - 1) * 3 - 1.25, 0.15, -90);
      game.scene.add(leftBorder);
      
      const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
      rightBorder.position.set((i - 1) * 3 + 1.25, 0.15, -90);
      game.scene.add(rightBorder);
    }
  };

  const createOptimizedParticles = () => {
    const game = gameRef.current;
    const particleCount = 200; // –£–º–µ–Ω—å—à–∏–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    const particles = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 50;
      positions[i * 3 + 1] = Math.random() * 30;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0xFF1493,
      size: 0.2,
      transparent: true,
      opacity: 0.6
    });
    
    const particleSystem = new THREE.Points(particles, particleMaterial);
    game.scene.add(particleSystem);
  };

  // –†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
  const createObstacle = (lane, distance, type = 'standard') => {
    const game = gameRef.current;
    let obstacle;
    
    switch(type) {
      case 'wall':
        const wallGeometry = new THREE.BoxGeometry(2, 3, 0.5);
        const wallMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xFF0040,
          emissive: 0x440011 
        });
        obstacle = new THREE.Mesh(wallGeometry, wallMaterial);
        break;
      case 'spikes':
        const spikesGeometry = new THREE.ConeGeometry(0.5, 2, 6);
        const spikesMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xFF8000,
          emissive: 0x442200 
        });
        obstacle = new THREE.Mesh(spikesGeometry, spikesMaterial);
        break;
      case 'laser':
        const laserGeometry = new THREE.BoxGeometry(2, 0.2, 0.2);
        const laserMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xFF0000,
          emissive: 0xFF0000,
          transparent: true,
          opacity: 0.8
        });
        obstacle = new THREE.Mesh(laserGeometry, laserMaterial);
        obstacle.position.y = 1.5; // –í–∏—Å–∏—Ç –≤ –≤–æ–∑–¥—É—Ö–µ
        break;
      default:
        const obstacleGeometry = new THREE.BoxGeometry(1.5, 2, 1);
        const obstacleMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xFF0080,
          emissive: 0x330033 
        });
        obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
    }
    
    obstacle.position.set((lane - 1) * 3, type === 'laser' ? 1.5 : 1, -distance);
    obstacle.castShadow = true;
    game.scene.add(obstacle);
    game.obstacles.push({ mesh: obstacle, lane, type });
  };

  const createCollectible = (lane, distance) => {
    const game = gameRef.current;
    const collectibleGeometry = new THREE.OctahedronGeometry(0.4, 0);
    const collectibleMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x00FF00,
      emissive: 0x004400 
    });
    const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
    collectible.position.set((lane - 1) * 3, 1.5, -distance);
    collectible.castShadow = true;
    game.scene.add(collectible);
    game.collectibles.push({ mesh: collectible, lane });
  };

  // –°–∏—Å—Ç–µ–º–∞ –±–æ–Ω—É—Å–æ–≤
  const createPowerUp = (lane, distance, type) => {
    const game = gameRef.current;
    let powerUp;
    let color, emissive;
    
    switch(type) {
      case 'shield':
        color = 0x0080FF;
        emissive = 0x002244;
        break;
      case 'speed':
        color = 0xFFFF00;
        emissive = 0x444400;
        break;
      case 'breaker':
        color = 0xFF4000;
        emissive = 0x441100;
        break;
      default:
        color = 0xFF00FF;
        emissive = 0x440044;
    }
    
    const powerUpGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 6);
    const powerUpMaterial = new THREE.MeshPhongMaterial({ 
      color: color,
      emissive: emissive 
    });
    powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
    powerUp.position.set((lane - 1) * 3, 1, -distance);
    powerUp.castShadow = true;
    game.scene.add(powerUp);
    game.powerUps.push({ mesh: powerUp, lane, type });
  };

  const activatePowerUp = (type) => {
    const game = gameRef.current;
    game.activePowerUp = type;
    game.powerUpTimer = 5000; // 5 —Å–µ–∫—É–Ω–¥
    
    setGameState(prev => ({
      ...prev,
      activePowerUp: type,
      powerUpTimeLeft: 5
    }));
  };

  const handleKeyDown = useCallback((event) => {
    const game = gameRef.current;
    game.keys[event.code] = true;
    
    if (event.code === 'Escape') {
      event.preventDefault();
      if (game.gameRunning) {
        game.gameRunning = false;
        setGameState(prev => ({ 
          ...prev, 
          paused: true, 
          showMenu: true,
          gameStarted: false 
        }));
      }
      return;
    }
    
    if (event.code === 'Space') {
      event.preventDefault();
      if (!game.isJumping && game.gameRunning) {
        game.isJumping = true;
        game.jumpVelocity = 0.35; // –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ–∏–∑–∏–∫–∞ –ø—Ä—ã–∂–∫–∞
      }
    }
    
    if (event.code === 'ArrowLeft' && game.playerLane > 0 && game.gameRunning) {
      game.playerLane--;
    }
    if (event.code === 'ArrowRight' && game.playerLane < 2 && game.gameRunning) {
      game.playerLane++;
    }
  }, []);

  const handleKeyUp = useCallback((event) => {
    const game = gameRef.current;
    game.keys[event.code] = false;
  }, []);

  const checkCollisions = () => {
    const game = gameRef.current;
    const playerBoundingBox = new THREE.Box3().setFromObject(game.player);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏
    game.obstacles.forEach((obstacle, index) => {
      if (obstacle.lane === game.playerLane) {
        const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacle.mesh);
        const collision = playerBoundingBox.intersectsBox(obstacleBoundingBox);
        
        if (collision) {
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Å–æ—Ç—ã –¥–ª—è –ø—Ä—ã–∂–∫–æ–≤ —á–µ—Ä–µ–∑ –Ω–∏–∑–∫–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
          const canJumpOver = obstacle.type === 'laser' && game.isJumping && game.jumpHeight > 1;
          const hasShield = game.activePowerUp === 'shield';
          const canBreak = game.activePowerUp === 'breaker';
          
          if (!canJumpOver && !hasShield && !canBreak) {
            game.gameRunning = false;
            if (gameState.playerName) {
              saveScore(gameState.playerName, game.score, Math.floor(game.distance));
            }
            setGameState(prev => ({ ...prev, gameOver: true, gameStarted: false }));
          } else if (canBreak) {
            // –†–∞–∑—Ä—É—à–∞–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
            game.scene.remove(obstacle.mesh);
            game.obstacles.splice(index, 1);
            game.score += 5;
          }
        }
      }
    });
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–±–æ—Ä–∞ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
    game.collectibles.forEach((collectible, index) => {
      if (collectible.lane === game.playerLane) {
        const collectibleBoundingBox = new THREE.Box3().setFromObject(collectible.mesh);
        if (playerBoundingBox.intersectsBox(collectibleBoundingBox)) {
          game.scene.remove(collectible.mesh);
          game.collectibles.splice(index, 1);
          game.score += 10;
          setGameState(prev => ({ ...prev, score: game.score }));
        }
      }
    });
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–±–æ—Ä–∞ –±–æ–Ω—É—Å–æ–≤
    game.powerUps.forEach((powerUp, index) => {
      if (powerUp.lane === game.playerLane) {
        const powerUpBoundingBox = new THREE.Box3().setFromObject(powerUp.mesh);
        if (playerBoundingBox.intersectsBox(powerUpBoundingBox)) {
          game.scene.remove(powerUp.mesh);
          game.powerUps.splice(index, 1);
          activatePowerUp(powerUp.type);
          game.score += 20; // –ë–æ–Ω—É—Å –∑–∞ —Å–±–æ—Ä
        }
      }
    });
  };

  const gameLoop = useCallback((currentTime) => {
    const game = gameRef.current;
    if (!game.gameRunning) return;
    
    const deltaTime = currentTime - game.lastTime;
    game.lastTime = currentTime;
    
    // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
    const targetX = (game.playerLane - 1) * 3;
    game.player.position.x = THREE.MathUtils.lerp(game.player.position.x, targetX, 0.15);
    
    // –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ–∏–∑–∏–∫–∞ –ø—Ä—ã–∂–∫–∞
    if (game.isJumping) {
      game.jumpHeight += game.jumpVelocity;
      game.jumpVelocity -= 0.025; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
      game.player.position.y = 1 + Math.max(0, game.jumpHeight);
      
      if (game.jumpHeight <= 0) {
        game.isJumping = false;
        game.jumpHeight = 0;
        game.player.position.y = 1;
      }
    }
    
    // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ (–±—ã—Å—Ç—Ä–µ–µ)
    const speedMultiplier = game.activePowerUp === 'speed' ? 2 : 1;
    game.gameSpeed += 0.002 * speedMultiplier; // –ë—ã—Å—Ç—Ä–µ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ
    game.distance += game.gameSpeed;
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤
    if (game.powerUpTimer > 0) {
      game.powerUpTimer -= deltaTime;
      const timeLeft = Math.ceil(game.powerUpTimer / 1000);
      setGameState(prev => ({ ...prev, powerUpTimeLeft: timeLeft }));
      
      if (game.powerUpTimer <= 0) {
        game.activePowerUp = null;
        setGameState(prev => ({ ...prev, activePowerUp: null, powerUpTimeLeft: 0 }));
      }
    }
    
    // –î–≤–∏–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
    const moveSpeed = game.gameSpeed * 3;
    
    [...game.obstacles, ...game.collectibles, ...game.powerUps].forEach((obj, index, array) => {
      obj.mesh.position.z += moveSpeed;
      if (obj.mesh.position.z > 15) {
        game.scene.remove(obj.mesh);
        if (game.obstacles.includes(obj)) {
          game.obstacles.splice(game.obstacles.indexOf(obj), 1);
        } else if (game.collectibles.includes(obj)) {
          game.collectibles.splice(game.collectibles.indexOf(obj), 1);
        } else if (game.powerUps.includes(obj)) {
          game.powerUps.splice(game.powerUps.indexOf(obj), 1);
        }
      }
    });
    
    // –ê–Ω–∏–º–∞—Ü–∏—è —Å–æ–±–∏—Ä–∞–µ–º—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
    game.collectibles.forEach(collectible => {
      collectible.mesh.rotation.y += 0.05;
      collectible.mesh.rotation.x += 0.03;
    });
    
    game.powerUps.forEach(powerUp => {
      powerUp.mesh.rotation.y += 0.1;
      powerUp.mesh.position.y = 1 + Math.sin(currentTime * 0.005) * 0.2;
    });
    
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
    game.spawnTimer += deltaTime;
    if (game.spawnTimer > Math.max(300, 1000 - game.gameSpeed * 100)) { // –ß–∞—â–µ —Å–ø–∞–≤–Ω –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ —Å–∫–æ—Ä–æ—Å—Ç–∏
      game.spawnTimer = 0;
      
      const lane = Math.floor(Math.random() * 3);
      const random = Math.random();
      
      if (random < 0.6) {
        // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è (60%)
        const obstacleTypes = ['standard', 'wall', 'spikes', 'laser'];
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        createObstacle(lane, 50, type);
      } else if (random < 0.85) {
        // –ö—Ä–∏—Å—Ç–∞–ª–ª—ã (25%)
        createCollectible(lane, 55);
      } else {
        // –ë–æ–Ω—É—Å—ã (15%)
        const powerUpTypes = ['shield', 'speed', 'breaker'];
        const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
        createPowerUp(lane, 60, type);
      }
    }
    
    checkCollisions();
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI (—Ä–µ–∂–µ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
    if (Math.floor(currentTime / 100) !== Math.floor((currentTime - deltaTime) / 100)) {
      setGameState(prev => ({
        ...prev,
        distance: Math.floor(game.distance),
        speed: (5 + game.gameSpeed * 10).toFixed(1)
      }));
    }
    
    // –†–µ–Ω–¥–µ—Ä
    game.renderer.render(game.scene, game.camera);
    
    if (game.gameRunning) {
      requestAnimationFrame(gameLoop);
    }
  }, [gameState.playerName]);

  const startGame = () => {
    if (!gameState.nameEntered) return;
    
    const game = gameRef.current;
    game.gameRunning = true;
    game.gameSpeed = 0.5; // –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
    game.score = 0;
    game.distance = 0;
    game.playerLane = 1;
    game.activePowerUp = null;
    game.powerUpTimer = 0;
    game.player.position.set(0, 1, 8);
    
    // –û—á–∏—Å—Ç–∫–∞ –æ–±—ä–µ–∫—Ç–æ–≤
    [...game.obstacles, ...game.collectibles, ...game.powerUps].forEach(obj => {
      game.scene.remove(obj.mesh);
    });
    game.obstacles = [];
    game.collectibles = [];
    game.powerUps = [];
    
    setGameState(prev => ({
      ...prev,
      score: 0,
      distance: 0,
      speed: 5.0,
      gameStarted: true,
      gameOver: false,
      showMenu: false,
      paused: false,
      activePowerUp: null,
      powerUpTimeLeft: 0
    }));
    
    game.lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  };

  const restartGame = () => {
    setGameState(prev => ({
      ...prev,
      gameOver: false,
      showMenu: true,
      gameStarted: false
    }));
  };

  const showLeaderboardScreen = () => {
    setGameState(prev => ({
      ...prev,
      showLeaderboard: true,
      showMenu: false
    }));
  };

  const backToMenu = () => {
    setGameState(prev => ({
      ...prev,
      showLeaderboard: false,
      showMenu: true,
      gameOver: false,
      gameStarted: false,
      paused: false
    }));
  };

  const handleNameSubmit = (e) => {
    e.preventDefault();
    if (gameState.playerName.trim()) {
      setGameState(prev => ({ ...prev, nameEntered: true }));
    }
  };

  useEffect(() => {
    initThreeJS();
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    const handleResize = () => {
      const game = gameRef.current;
      if (game.camera && game.renderer) {
        game.camera.aspect = window.innerWidth / window.innerHeight;
        game.camera.updateProjectionMatrix();
        game.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('resize', handleResize);
      
      if (mountRef.current && gameRef.current.renderer) {
        mountRef.current.removeChild(gameRef.current.renderer.domElement);
      }
    };
  }, [initThreeJS, handleKeyDown, handleKeyUp, gameLoop]);

  const powerUpNames = {
    shield: 'üõ°Ô∏è –©–ò–¢',
    speed: '‚ö° –°–ö–û–†–û–°–¢–¨',
    breaker: 'üí• –†–ê–ó–†–£–®–ò–¢–ï–õ–¨'
  };

  return (
    <div className="relative w-full h-screen bg-black overflow-hidden">
      <div ref={mountRef} className="w-full h-full" />
      
      {/* UI –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã */}
      {gameState.gameStarted && !gameState.paused && (
        <>
          <div className="absolute top-4 left-4 text-white font-mono">
            <div className="bg-black bg-opacity-50 p-4 rounded-lg border border-purple-500">
              <div className="text-purple-400 text-lg">NEON DRIFT: SPHERE RUN</div>
              <div className="text-yellow-400">Player: {gameState.playerName}</div>
              <div className="text-green-400">Score: {gameState.score}</div>
              <div className="text-blue-400">Distance: {gameState.distance}m</div>
              <div className="text-pink-400">Speed: {gameState.speed}x</div>
            </div>
          </div>
          
          {/* –ê–∫—Ç–∏–≤–Ω—ã–π –±–æ–Ω—É—Å */}
          {gameState.activePowerUp && (
            <div className="absolute top-4 right-4 text-white font-mono">
              <div className="bg-black bg-opacity-50 p-3 rounded-lg border border-yellow-500">
                <div className="text-yellow-400 text-lg">{powerUpNames[gameState.activePowerUp]}</div>
                <div className="text-white">–í—Ä–µ–º—è: {gameState.powerUpTimeLeft}—Å</div>
              </div>
            </div>
          )}
          
          <div className="absolute bottom-4 left-4 text-white font-mono">
            <div className="bg-black bg-opacity-50 p-4 rounded-lg border border-cyan-500">
              <div className="text-cyan-400 text-sm">–£–ü–†–ê–í–õ–ï–ù–ò–ï:</div>
              <div className="text-xs">‚Üê ‚Üí –î–≤–∏–∂–µ–Ω–∏–µ</div>
              <div className="text-xs">SPACE –ü—Ä—ã–∂–æ–∫</div>
              <div className="text-xs">ESC –ú–µ–Ω—é</div>
            </div>
          </div>
          
          {/* –õ–µ–≥–µ–Ω–¥–∞ –±–æ–Ω—É—Å–æ–≤ */}
          <div className="absolute bottom-4 right-4 text-white font-mono">
            <div className="bg-black bg-opacity-50 p-3 rounded-lg border border-green-500">
              <div className="text-green-400 text-sm">–ë–û–ù–£–°–´:</div>
              <div className="text-xs">üõ°Ô∏è –©–∏—Ç - –∑–∞—â–∏—Ç–∞</div>
              <div className="text-xs">‚ö° –°–∫–æ—Ä–æ—Å—Ç—å - —É—Å–∫–æ—Ä–µ–Ω–∏–µ</div>
              <div className="text-xs">üí• –†–∞–∑—Ä—É—à–∏—Ç–µ–ª—å - –ø—Ä–æ–ª–∞–º—ã–≤–∞–Ω–∏–µ</div>
            </div>
          </div>
        </>
      )}
      
      {/* –ú–µ–Ω—é/–≠–∫—Ä–∞–Ω—ã */}
      {(gameState.showMenu || gameState.gameOver || gameState.showLeaderboard || !gameState.nameEntered) && (
        <div className="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center">
          <div className="text-center text-white font-mono max-w-lg">
            
            <h1 className="text-6xl font-bold text-purple-400 mb-4 animate-pulse">
              NEON DRIFT
            </h1>
            <h2 className="text-3xl text-cyan-400 mb-8">SPHERE RUN</h2>
            
            {/* –í–≤–æ–¥ –∏–º–µ–Ω–∏ */}
            {!gameState.nameEntered && (
              <div>
                <div className="text-xl text-yellow-400 mb-4">–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫–Ω–µ–π–º:</div>
                <form onSubmit={handleNameSubmit} className="mb-6">
                  <input
                    type="text"
                    value={gameState.playerName}
                    onChange={(e) => setGameState(prev => ({ ...prev, playerName: e.target.value }))}
                    className="bg-gray-800 border border-purple-500 rounded px-4 py-2 text-white text-center text-xl mb-4 w-64"
                    placeholder="–í–∞—à –Ω–∏–∫–Ω–µ–π–º"
                    maxLength="15"
                    autoFocus
                  />
                  <br />
                  <button
                    type="submit"
                    disabled={!gameState.playerName.trim()}
                    className="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white font-bold py-2 px-6 rounded transition-colors"
                  >
                    –ü–û–î–¢–í–ï–†–î–ò–¢–¨
                  </button>
                </form>
              </div>
            )}
            
            {/* –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é */}
            {gameState.nameEntered && gameState.showMenu && !gameState.gameOver && (
              <div>
                <div className="text-green-400 text-lg mb-6">–ü—Ä–∏–≤–µ—Ç, {gameState.playerName}!</div>
                <button
                  onClick={startGame}
                  className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors border-2 border-purple-400 hover:border-purple-300 mb-4 block mx-auto"
                >
                  –ù–ê–ß–ê–¢–¨ –ò–ì–†–£
                </button>
                <button
                  onClick={showLeaderboardScreen}
                  className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded transition-colors mb-4 block mx-auto"
                >
                  –†–ï–ô–¢–ò–ù–ì –ò–ì–†–û–ö–û–í
                </button>
                <button
                  onClick={() => setGameState(prev => ({ ...prev, nameEntered: false, playerName: '' }))}
                  className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors block mx-auto"
                >
                  –°–ú–ï–ù–ò–¢–¨ –ù–ò–ö
                </button>
              </div>
            )}
            
            {/* Game Over */}
            {gameState.gameOver && (
              <div>
                <div className="text-red-400 text-3xl mb-4">GAME OVER</div>
                <div className="text-green-400 text-xl mb-2">–ò–≥—Ä–æ–∫: {gameState.playerName}</div>
                <div className="text-green-400 text-xl mb-2">–û—á–∫–∏: {gameState.score}</div>
                <div className="text-blue-400 text-lg mb-6">–î–∏—Å—Ç–∞–Ω—Ü–∏—è: {gameState.distance}m</div>
                
                <button
                  onClick={startGame}
                  className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors border-2 border-purple-400 hover:border-purple-300 mb-4 block mx-auto"
                >
                  –ò–ì–†–ê–¢–¨ –°–ù–û–í–ê
                </button>
                <button
                  onClick={backToMenu}
                  className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors block mx-auto"
                >
                  –í –ú–ï–ù–Æ
                </button>
              </div>
            )}
            
            {/* –†–µ–π—Ç–∏–Ω–≥ */}
            {gameState.showLeaderboard && (
              <div>
                <div className="text-yellow-400 text-2xl mb-6">üèÜ –†–ï–ô–¢–ò–ù–ì –ò–ì–†–û–ö–û–í</div>
                <div className="bg-black bg-opacity-50 p-4 rounded-lg border border-yellow-500 mb-6 max-h-64 overflow-y-auto">
                  {leaderboard.length === 0 ? (
                    <div className="text-gray-400">–†–µ–∫–æ—Ä–¥–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</div>
                  ) : (
                    leaderboard.map((player, index) => (
                      <div key={index} className="flex justify-between items-center py-1 border-b border-gray-700 last:border-b-0">
                        <span className="text-yellow-400">#{index + 1}</span>
                        <span className="text-white flex-1 mx-4 text-left">{player.name}</span>
                        <span className="text-green-400">{player.score}</span>
                        <span className="text-blue-400 ml-2 text-sm">{player.distance}m</span>
                      </div>
                    ))
                  )}
                </div>
                <button
                  onClick={backToMenu}
                  className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors"
                >
                  –ù–ê–ó–ê–î
                </button>
              </div>
            )}
            
            {(gameState.showMenu || !gameState.nameEntered) && (
              <div className="mt-8 text-sm text-gray-400">
                <p>–í —Ü–∏—Ñ—Ä–æ–≤–æ–º –º–µ–≥–∞–ø–æ–ª–∏—Å–µ NOVA</p>
                <p>–¢–æ–ª—å–∫–æ –ª—É—á—à–∏–µ –≤—ã–∂–∏–≤–∞—é—Ç –≤ –≥–ª–∏—Ç—á-—Å–∏—Å—Ç–µ–º–µ</p>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default NeonDriftGame;
