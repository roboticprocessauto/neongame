<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Drift: Sphere Run</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const NeonDriftGame = () => {
          const mountRef = useRef(null);
          const gameRef = useRef({
            scene: null,
            camera: null,
            renderer: null,
            player: null,
            obstacles: [],
            collectibles: [],
            gameSpeed: 0.1,
            playerLane: 1,
            isJumping: false,
            jumpHeight: 0,
            jumpVelocity: 0,
            score: 0,
            distance: 0,
            gameRunning: false,
            spawnTimer: 0,
            keys: {},
            lastTime: 0
          });

          const [gameState, setGameState] = useState({
            score: 0,
            distance: 0,
            speed: 1.0,
            gameStarted: false,
            gameOver: false,
            paused: false,
            showMenu: true,
            showLeaderboard: false,
            playerName: '',
            nameEntered: false
          });

          const [leaderboard, setLeaderboard] = useState([]);

          // Load leaderboard from localStorage
          useEffect(() => {
            const savedLeaderboard = localStorage.getItem('neonDriftLeaderboard');
            if (savedLeaderboard) {
              setLeaderboard(JSON.parse(savedLeaderboard));
            }
          }, []);

          // Save score to leaderboard
          const saveScore = (name, score, distance) => {
            const newLeaderboard = [...leaderboard];
            const existingPlayerIndex = newLeaderboard.findIndex(player => player.name === name);
            
            if (existingPlayerIndex !== -1) {
              if (score > newLeaderboard[existingPlayerIndex].score) {
                newLeaderboard[existingPlayerIndex] = { name, score, distance, date: new Date().toLocaleDateString() };
              }
            } else {
              newLeaderboard.push({ name, score, distance, date: new Date().toLocaleDateString() });
            }
            
            newLeaderboard.sort((a, b) => b.score - a.score);
            const topLeaderboard = newLeaderboard.slice(0, 10);
            
            setLeaderboard(topLeaderboard);
            localStorage.setItem('neonDriftLeaderboard', JSON.stringify(topLeaderboard));
          };

          const initThreeJS = useCallback(() => {
            const game = gameRef.current;
            
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.Fog(0x000000, 50, 200);
            
            game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            game.camera.position.set(0, 8, 12);
            game.camera.lookAt(0, 0, 0);
            
            game.renderer = new THREE.WebGLRenderer({ antialias: true });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.setClearColor(0x000000);
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            if (mountRef.current) {
              mountRef.current.appendChild(game.renderer.domElement);
            }
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            game.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x8A2BE2, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            game.scene.add(directionalLight);
            
            const playerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const playerMaterial = new THREE.MeshPhongMaterial({ 
              color: 0x8A2BE2,
              emissive: 0x4B0082,
              shininess: 100
            });
            game.player = new THREE.Mesh(playerGeometry, playerMaterial);
            game.player.position.set(0, 1, 8);
            game.player.castShadow = true;
            game.scene.add(game.player);
            
            createTrack();
            createParticles();
          }, []);

          const createTrack = () => {
            const game = gameRef.current;
            
            for (let i = 0; i < 3; i++) {
              const laneGeometry = new THREE.PlaneGeometry(2, 200);
              const laneMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.8 
              });
              const lane = new THREE.Mesh(laneGeometry, laneMaterial);
              lane.rotation.x = -Math.PI / 2;
              lane.position.set((i - 1) * 3, 0, -90);
              lane.receiveShadow = true;
              game.scene.add(lane);
              
              const borderGeometry = new THREE.BoxGeometry(0.1, 0.2, 200);
              const borderMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00FFFF,
                emissive: 0x005555 
              });
              
              const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
              leftBorder.position.set((i - 1) * 3 - 1, 0.1, -90);
              game.scene.add(leftBorder);
              
              const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
              rightBorder.position.set((i - 1) * 3 + 1, 0.1, -90);
              game.scene.add(rightBorder);
            }
          };

          const createParticles = () => {
            const game = gameRef.current;
            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
              positions[i * 3] = (Math.random() - 0.5) * 100;
              positions[i * 3 + 1] = Math.random() * 50;
              positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
              color: 0xFF1493,
              size: 0.1,
              transparent: true,
              opacity: 0.8
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            game.scene.add(particleSystem);
          };

          const createObstacle = (lane, distance) => {
            const game = gameRef.current;
            const obstacleGeometry = new THREE.BoxGeometry(1.5, 2, 1);
            const obstacleMaterial = new THREE.MeshPhongMaterial({ 
              color: 0xFF0080,
              emissive: 0x330033 
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set((lane - 1) * 3, 1, -distance);
            obstacle.castShadow = true;
            game.scene.add(obstacle);
            game.obstacles.push({ mesh: obstacle, lane });
          };

          const createCollectible = (lane, distance) => {
            const game = gameRef.current;
            const collectibleGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const collectibleMaterial = new THREE.MeshPhongMaterial({ 
              color: 0x00FF00,
              emissive: 0x004400 
            });
            const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
            collectible.position.set((lane - 1) * 3, 1, -distance);
            collectible.castShadow = true;
            game.scene.add(collectible);
            game.collectibles.push({ mesh: collectible, lane });
          };

          const handleKeyDown = useCallback((event) => {
            const game = gameRef.current;
            game.keys[event.code] = true;
            
            if (event.code === 'Escape') {
              event.preventDefault();
              if (game.gameRunning) {
                game.gameRunning = false;
                setGameState(prev => ({ 
                  ...prev, 
                  paused: true, 
                  showMenu: true,
                  gameStarted: false 
                }));
              }
              return;
            }
            
            if (event.code === 'Space') {
              event.preventDefault();
              if (!game.isJumping && game.gameRunning) {
                game.isJumping = true;
                game.jumpVelocity = 0.3;
              }
            }
            
            if (event.code === 'ArrowLeft' && game.playerLane > 0 && game.gameRunning) {
              game.playerLane--;
            }
            if (event.code === 'ArrowRight' && game.playerLane < 2 && game.gameRunning) {
              game.playerLane++;
            }
          }, []);

          const handleKeyUp = useCallback((event) => {
            const game = gameRef.current;
            game.keys[event.code] = false;
          }, []);

          const checkCollisions = () => {
            const game = gameRef.current;
            const playerBoundingBox = new THREE.Box3().setFromObject(game.player);
            
            game.obstacles.forEach((obstacle, index) => {
              if (obstacle.lane === game.playerLane) {
                const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacle.mesh);
                if (playerBoundingBox.intersectsBox(obstacleBoundingBox) && !game.isJumping) {
                  game.gameRunning = false;
                  if (gameState.playerName) {
                    saveScore(gameState.playerName, game.score, Math.floor(game.distance));
                  }
                  setGameState(prev => ({ ...prev, gameOver: true, gameStarted: false }));
                }
              }
            });
            
            game.collectibles.forEach((collectible, index) => {
              if (collectible.lane === game.playerLane) {
                const collectibleBoundingBox = new THREE.Box3().setFromObject(collectible.mesh);
                if (playerBoundingBox.intersectsBox(collectibleBoundingBox)) {
                  game.scene.remove(collectible.mesh);
                  game.collectibles.splice(index, 1);
                  game.score += 10;
                  setGameState(prev => ({ ...prev, score: game.score }));
                }
              }
            });
          };

          const gameLoop = useCallback((currentTime) => {
            const game = gameRef.current;
            if (!game.gameRunning) return;
            
            const deltaTime = currentTime - game.lastTime;
            game.lastTime = currentTime;
            
            game.player.position.x = THREE.MathUtils.lerp(game.player.position.x, (game.playerLane - 1) * 3, 0.1);
            
            if (game.isJumping) {
              game.jumpHeight += game.jumpVelocity;
              game.jumpVelocity -= 0.02;
              game.player.position.y = 1 + game.jumpHeight;
              
              if (game.jumpHeight <= 0) {
                game.isJumping = false;
                game.jumpHeight = 0;
                game.player.position.y = 1;
              }
            }
            
            game.gameSpeed += 0.0001;
            game.distance += game.gameSpeed;
            
            game.obstacles.forEach((obstacle, index) => {
              obstacle.mesh.position.z += game.gameSpeed * 2;
              if (obstacle.mesh.position.z > 15) {
                game.scene.remove(obstacle.mesh);
                game.obstacles.splice(index, 1);
              }
            });
            
            game.collectibles.forEach((collectible, index) => {
              collectible.mesh.position.z += game.gameSpeed * 2;
              collectible.mesh.rotation.y += 0.1;
              if (collectible.mesh.position.z > 15) {
                game.scene.remove(collectible.mesh);
                game.collectibles.splice(index, 1);
              }
            });
            
            game.spawnTimer += deltaTime;
            if (game.spawnTimer > 1000) {
              game.spawnTimer = 0;
              
              if (Math.random() < 0.7) {
                const lane = Math.floor(Math.random() * 3);
                createObstacle(lane, 50);
              }
              
              if (Math.random() < 0.5) {
                const lane = Math.floor(Math.random() * 3);
                createCollectible(lane, 60);
              }
            }
            
            checkCollisions();
            
            setGameState(prev => ({
              ...prev,
              distance: Math.floor(game.distance),
              speed: (game.gameSpeed * 20).toFixed(1)
            }));
            
            game.renderer.render(game.scene, game.camera);
            
            if (game.gameRunning) {
              requestAnimationFrame(gameLoop);
            }
          }, []);

          const startGame = () => {
            if (!gameState.nameEntered) return;
            
            const game = gameRef.current;
            game.gameRunning = true;
            game.gameSpeed = 0.1;
            game.score = 0;
            game.distance = 0;
            game.playerLane = 1;
            game.player.position.set(0, 1, 8);
            
            game.obstacles.forEach(obstacle => game.scene.remove(obstacle.mesh));
            game.collectibles.forEach(collectible => game.scene.remove(collectible.mesh));
            game.obstacles = [];
            game.collectibles = [];
            
            setGameState(prev => ({
              ...prev,
              score: 0,
              distance: 0,
              speed: 1.0,
              gameStarted: true,
              gameOver: false,
              showMenu: false,
              paused: false
            }));
            
            game.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
          };

          const restartGame = () => {
            setGameState(prev => ({
              ...prev,
              gameOver: false,
              showMenu: true,
              gameStarted: false
            }));
          };

          const showLeaderboardScreen = () => {
            setGameState(prev => ({
              ...prev,
              showLeaderboard: true,
              showMenu: false
            }));
          };

          const backToMenu = () => {
            setGameState(prev => ({
              ...prev,
              showLeaderboard: false,
              showMenu: true,
              gameOver: false,
              gameStarted: false,
              paused: false
            }));
          };

          const handleNameSubmit = (e) => {
            e.preventDefault();
            if (gameState.playerName.trim()) {
              setGameState(prev => ({ ...prev, nameEntered: true }));
            }
          };

          useEffect(() => {
            initThreeJS();
            
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            const handleResize = () => {
              const game = gameRef.current;
              if (game.camera && game.renderer) {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
              }
            };
            
            window.addEventListener('resize', handleResize);
            
            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
              window.removeEventListener('resize', handleResize);
              
              if (mountRef.current && gameRef.current.renderer) {
                mountRef.current.removeChild(gameRef.current.renderer.domElement);
              }
            };
          }, [initThreeJS, handleKeyDown, handleKeyUp, gameLoop]);

          return React.createElement('div', { className: "relative w-full h-screen bg-black overflow-hidden" },
            React.createElement('div', { ref: mountRef, className: "w-full h-full" }),
            
            gameState.gameStarted && !gameState.paused && React.createElement('div', { className: "absolute top-4 left-4 text-white font-mono" },
              React.createElement('div', { className: "bg-black bg-opacity-50 p-4 rounded-lg border border-purple-500" },
                React.createElement('div', { className: "text-purple-400 text-lg" }, "NEON DRIFT: SPHERE RUN"),
                React.createElement('div', { className: "text-yellow-400" }, `Player: ${gameState.playerName}`),
                React.createElement('div', { className: "text-green-400" }, `Score: ${gameState.score}`),
                React.createElement('div', { className: "text-blue-400" }, `Distance: ${gameState.distance}m`),
                React.createElement('div', { className: "text-pink-400" }, `Speed: ${gameState.speed}x`)
              )
            ),
            
            gameState.gameStarted && !gameState.paused && React.createElement('div', { className: "absolute bottom-4 left-4 text-white font-mono" },
              React.createElement('div', { className: "bg-black bg-opacity-50 p-4 rounded-lg border border-cyan-500" },
                React.createElement('div', { className: "text-cyan-400 text-sm" }, "CONTROLS:"),
                React.createElement('div', { className: "text-xs" }, "← → Arrow Keys: Move"),
                React.createElement('div', { className: "text-xs" }, "SPACE: Jump"),
                React.createElement('div', { className: "text-xs" }, "ESC: Menu")
              )
            ),
            
            (gameState.showMenu || gameState.gameOver || gameState.showLeaderboard || !gameState.nameEntered) && React.createElement('div', { className: "absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center" },
              React.createElement('div', { className: "text-center text-white font-mono max-w-lg" },
                
                React.createElement('h1', { className: "text-6xl font-bold text-purple-400 mb-4" }, "NEON DRIFT"),
                React.createElement('h2', { className: "text-3xl text-cyan-400 mb-8" }, "SPHERE RUN"),
                
                !gameState.nameEntered && React.createElement('div', null,
                  React.createElement('div', { className: "text-xl text-yellow-400 mb-4" }, "Введите ваш никнейм:"),
                  React.createElement('form', { onSubmit: handleNameSubmit, className: "mb-6" },
                    React.createElement('input', {
                      type: "text",
                      value: gameState.playerName,
                      onChange: (e) => setGameState(prev => ({ ...prev, playerName: e.target.value })),
                      className: "bg-gray-800 border border-purple-500 rounded px-4 py-2 text-white text-center text-xl mb-4 w-64",
                      placeholder: "Ваш никнейм",
                      maxLength: "15",
                      autoFocus: true
                    }),
                    React.createElement('br'),
                    React.createElement('button', {
                      type: "submit",
                      disabled: !gameState.playerName.trim(),
                      className: "bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 text-white font-bold py-2 px-6 rounded transition-colors"
                    }, "ПОДТВЕРДИТЬ")
                  )
                ),
                
                gameState.nameEntered && gameState.showMenu && !gameState.gameOver && React.createElement('div', null,
                  React.createElement('div', { className: "text-green-400 text-lg mb-6" }, `Привет, ${gameState.playerName}!`),
                  React.createElement('button', {
                    onClick: startGame,
                    className: "bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors border-2 border-purple-400 hover:border-purple-300 mb-4 block mx-auto"
                  }, "НАЧАТЬ ИГРУ"),
                  React.createElement('button', {
                    onClick: showLeaderboardScreen,
                    className: "bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded transition-colors mb-4 block mx-auto"
                  }, "РЕЙТИНГ ИГРОКОВ"),
                  React.createElement('button', {
                    onClick: () => setGameState(prev => ({ ...prev, nameEntered: false, playerName: '' })),
                    className: "bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors block mx-auto"
                  }, "СМЕНИТЬ НИК")
                ),
                
                gameState.gameOver && React.createElement('div', null,
                  React.createElement('div', { className: "text-red-400 text-3xl mb-4" }, "GAME OVER"),
                  React.createElement('div', { className: "text-green-400 text-xl mb-2" }, `Игрок: ${gameState.playerName}`),
                  React.createElement('div', { className: "text-green-400 text-xl mb-2" }, `Очки: ${gameState.score}`),
                  React.createElement('div', { className: "text-blue-400 text-lg mb-6" }, `Дистанция: ${gameState.distance}m`),
                  
                  React.createElement('button', {
                    onClick: startGame,
                    className: "bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors border-2 border-purple-400 hover:border-purple-300 mb-4 block mx-auto"
                  }, "ИГРАТЬ СНОВА"),
                  React.createElement('button', {
                    onClick: backToMenu,
                    className: "bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors block mx-auto"
                  }, "В МЕНЮ")
                ),
                
                gameState.showLeaderboard && React.createElement('div', null,
                  React.createElement('div', { className: "text-yellow-400 text-2xl mb-6" }, "🏆 РЕЙТИНГ ИГРОКОВ"),
                  React.createElement('div', { className: "bg-black bg-opacity-50 p-4 rounded-lg border border-yellow-500 mb-6 max-h-64 overflow-y-auto" },
                    leaderboard.length === 0 ? React.createElement('div', { className: "text-gray-400" }, "Рекордов пока нет") :
                    leaderboard.map((player, index) =>
                      React.createElement('div', { key: index, className: "flex justify-between items-center py-1 border-b border-gray-700 last:border-b-0" },
                        React.createElement('span', { className: "text-yellow-400" }, `#${index + 1}`),
                        React.createElement('span', { className: "text-white flex-1 mx-4 text-left" }, player.name),
                        React.createElement('span', { className: "text-green-400" }, player.score),
                        React.createElement('span', { className: "text-blue-400 ml-2 text-sm" }, `${player.distance}m`)
                      )
                    )
                  ),
                  React.createElement('button', {
                    onClick: backToMenu,
                    className: "bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded transition-colors"
                  }, "НАЗАД")
                ),
                
                (gameState.showMenu || !gameState.nameEntered) && React.createElement('div', { className: "mt-8 text-sm text-gray-400" },
                  React.createElement('p', null, "В цифровом мегаполисе NOVA"),
                  React.createElement('p', null, "Только лучшие выживают в глитч-системе")
                )
              )
            )
          );
        };

        ReactDOM.render(React.createElement(NeonDriftGame), document.getElementById('root'));
    </script>
</body>
</html>