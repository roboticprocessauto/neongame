<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Drift: Sphere Run</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .ui-overlay {
            position: absolute;
            z-index: 100;
            color: white;
            font-family: 'Courier New', monospace;
        }
        
        .game-stats {
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #8A2BE2;
        }
        
        .power-up-display {
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FFD700;
        }
        
        .controls {
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00FFFF;
        }
        
        .bonuses-legend {
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00FF00;
        }
        
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .menu-content {
            text-align: center;
            max-width: 500px;
            padding: 20px;
        }
        
        .title {
            font-size: 4rem;
            color: #8A2BE2;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #8A2BE2;
            animation: pulse 2s infinite;
        }
        
        .subtitle {
            font-size: 2rem;
            color: #00FFFF;
            margin-bottom: 30px;
        }
        
        .button {
            background: #8A2BE2;
            color: white;
            border: 2px solid #4B0082;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            margin: 8px;
            transition: all 0.3s;
            display: inline-block;
        }
        
        .button:hover {
            background: #4B0082;
            border-color: #8A2BE2;
            transform: scale(1.05);
        }
        
        .button:disabled {
            background: #444;
            border-color: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .button.primary {
            font-size: 20px;
            padding: 15px 30px;
            border-width: 3px;
        }
        
        .button.secondary {
            background: #0066CC;
            border-color: #004499;
        }
        
        .button.secondary:hover {
            background: #004499;
            border-color: #0066CC;
        }
        
        .input {
            background: #333;
            border: 2px solid #8A2BE2;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            text-align: center;
            margin: 10px;
            width: 250px;
        }
        
        .leaderboard {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #444;
        }
        
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .hidden {
            display: none !important;
        }
        
        .text-purple { color: #8A2BE2; }
        .text-cyan { color: #00FFFF; }
        .text-green { color: #00FF00; }
        .text-yellow { color: #FFD700; }
        .text-red { color: #FF4444; }
        .text-blue { color: #4488FF; }
        .text-gray { color: #888; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game UI Overlays -->
        <div id="gameUI" class="hidden">
            <div class="ui-overlay game-stats">
                <div class="text-purple" style="font-size: 18px;">NEON DRIFT: SPHERE RUN</div>
                <div class="text-yellow">Player: <span id="playerDisplay"></span></div>
                <div class="text-green">Score: <span id="scoreDisplay">0</span></div>
                <div class="text-blue">Distance: <span id="distanceDisplay">0</span>m</div>
                <div style="color: #FF1493;">Speed: <span id="speedDisplay">5.0</span>x</div>
            </div>
            
            <div id="powerUpUI" class="ui-overlay power-up-display hidden">
                <div class="text-yellow" style="font-size: 18px;" id="powerUpName"></div>
                <div class="text-white">–í—Ä–µ–º—è: <span id="powerUpTime">0</span>—Å</div>
            </div>
            
            <div class="ui-overlay controls">
                <div class="text-cyan" style="font-size: 14px;">–£–ü–†–ê–í–õ–ï–ù–ò–ï:</div>
                <div style="font-size: 12px;">‚Üê ‚Üí –î–≤–∏–∂–µ–Ω–∏–µ</div>
                <div style="font-size: 12px;">SPACE –ü—Ä—ã–∂–æ–∫</div>
                <div style="font-size: 12px;">ESC –ú–µ–Ω—é</div>
            </div>
            
            <div class="ui-overlay bonuses-legend">
                <div class="text-green" style="font-size: 14px;">–ë–û–ù–£–°–´:</div>
                <div style="font-size: 12px;">üõ°Ô∏è –©–∏—Ç - –∑–∞—â–∏—Ç–∞</div>
                <div style="font-size: 12px;">‚ö° –°–∫–æ—Ä–æ—Å—Ç—å - —É—Å–∫–æ—Ä–µ–Ω–∏–µ</div>
                <div style="font-size: 12px;">üí• –†–∞–∑—Ä—É—à–∏—Ç–µ–ª—å - –ø—Ä–æ–ª–∞–º—ã–≤–∞–Ω–∏–µ</div>
            </div>
        </div>
        
        <!-- Menu Screens -->
        <div id="menuScreen" class="menu-screen">
            <div class="menu-content">
                <h1 class="title">NEON DRIFT</h1>
                <h2 class="subtitle">SPHERE RUN</h2>
                
                <!-- Name Input -->
                <div id="nameInput">
                    <div class="text-yellow" style="font-size: 20px; margin-bottom: 15px;">–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫–Ω–µ–π–º:</div>
                    <form id="nameForm">
                        <input type="text" id="playerName" class="input" placeholder="–í–∞—à –Ω–∏–∫–Ω–µ–π–º" maxlength="15" autofocus>
                        <br>
                        <button type="submit" class="button">–ü–û–î–¢–í–ï–†–î–ò–¢–¨</button>
                    </form>
                </div>
                
                <!-- Main Menu -->
                <div id="mainMenu" class="hidden">
                    <div class="text-green" style="font-size: 18px; margin-bottom: 20px;">–ü—Ä–∏–≤–µ—Ç, <span id="welcomeName"></span>!</div>
                    <button id="startGame" class="button primary">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button><br>
                    <button id="showLeaderboard" class="button secondary">–†–ï–ô–¢–ò–ù–ì –ò–ì–†–û–ö–û–í</button><br>
                    <button id="changeName" class="button">–°–ú–ï–ù–ò–¢–¨ –ù–ò–ö</button>
                </div>
                
                <!-- Game Over -->
                <div id="gameOver" class="hidden">
                    <div class="text-red" style="font-size: 2rem; margin-bottom: 15px;">GAME OVER</div>
                    <div class="text-green" style="font-size: 20px;">–ò–≥—Ä–æ–∫: <span id="gameOverPlayer"></span></div>
                    <div class="text-green" style="font-size: 20px;">–û—á–∫–∏: <span id="gameOverScore"></span></div>
                    <div class="text-blue" style="font-size: 18px; margin-bottom: 20px;">–î–∏—Å—Ç–∞–Ω—Ü–∏—è: <span id="gameOverDistance"></span>m</div>
                    <button id="playAgain" class="button primary">–ò–ì–†–ê–¢–¨ –°–ù–û–í–ê</button><br>
                    <button id="backToMenu" class="button">–í –ú–ï–ù–Æ</button>
                </div>
                
                <!-- Leaderboard -->
                <div id="leaderboardScreen" class="hidden">
                    <div class="text-yellow" style="font-size: 24px; margin-bottom: 20px;">üèÜ –†–ï–ô–¢–ò–ù–ì –ò–ì–†–û–ö–û–í</div>
                    <div id="leaderboardList" class="leaderboard">
                        <div class="text-gray">–†–µ–∫–æ—Ä–¥–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</div>
                    </div>
                    <button id="leaderboardBack" class="button">–ù–ê–ó–ê–î</button>
                </div>
                
                <div class="text-gray" style="font-size: 14px; margin-top: 30px;">
                    <p>–í —Ü–∏—Ñ—Ä–æ–≤–æ–º –º–µ–≥–∞–ø–æ–ª–∏—Å–µ NOVA</p>
                    <p>–¢–æ–ª—å–∫–æ –ª—É—á—à–∏–µ –≤—ã–∂–∏–≤–∞—é—Ç –≤ –≥–ª–∏—Ç—á-—Å–∏—Å—Ç–µ–º–µ</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NeonDriftGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                
                this.obstacles = [];
                this.collectibles = [];
                this.powerUps = [];
                
                this.gameSpeed = 0.3;
                this.playerLane = 1;
                this.isJumping = false;
                this.jumpHeight = 0;
                this.jumpVelocity = 0;
                
                this.score = 0;
                this.distance = 0;
                this.gameRunning = false;
                this.spawnTimer = 0;
                
                this.activePowerUp = null;
                this.powerUpTimer = 0;
                
                this.keys = {};
                this.lastTime = 0;
                
                this.playerName = '';
                this.leaderboard = [];
                
                this.powerUpNames = {
                    shield: 'üõ°Ô∏è –©–ò–¢',
                    speed: '‚ö° –°–ö–û–†–û–°–¢–¨',
                    breaker: 'üí• –†–ê–ó–†–£–®–ò–¢–ï–õ–¨'
                };
                
                this.init();
            }
            
            init() {
                this.loadLeaderboard();
                this.setupEventListeners();
                this.initThreeJS();
            }
            
            loadLeaderboard() {
                try {
                    const saved = localStorage.getItem('neonDriftLeaderboard');
                    if (saved) {
                        this.leaderboard = JSON.parse(saved);
                    }
                } catch (e) {
                    console.log('Storage not available');
                }
            }
            
            saveScore(name, score, distance) {
                const existingIndex = this.leaderboard.findIndex(p => p.name === name);
                
                if (existingIndex !== -1) {
                    if (score > this.leaderboard[existingIndex].score) {
                        this.leaderboard[existingIndex] = { name, score, distance, date: new Date().toLocaleDateString() };
                    }
                } else {
                    this.leaderboard.push({ name, score, distance, date: new Date().toLocaleDateString() });
                }
                
                this.leaderboard.sort((a, b) => b.score - a.score);
                this.leaderboard = this.leaderboard.slice(0, 10);
                
                try {
                    localStorage.setItem('neonDriftLeaderboard', JSON.stringify(this.leaderboard));
                } catch (e) {
                    console.log('Could not save to storage');
                }
            }
            
            setupEventListeners() {
                // Name form
                document.getElementById('nameForm').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const name = document.getElementById('playerName').value.trim();
                    if (name) {
                        this.playerName = name;
                        this.showMainMenu();
                    }
                });
                
                // Menu buttons
                document.getElementById('startGame').addEventListener('click', () => this.startGame());
                document.getElementById('showLeaderboard').addEventListener('click', () => this.showLeaderboard());
                document.getElementById('changeName').addEventListener('click', () => this.showNameInput());
                document.getElementById('playAgain').addEventListener('click', () => this.startGame());
                document.getElementById('backToMenu').addEventListener('click', () => this.showMainMenu());
                document.getElementById('leaderboardBack').addEventListener('click', () => this.showMainMenu());
                
                // Game controls
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            handleKeyDown(event) {
                this.keys[event.code] = true;
                
                if (event.code === 'Escape') {
                    event.preventDefault();
                    if (this.gameRunning) {
                        this.gameRunning = false;
                        this.showMainMenu();
                    }
                    return;
                }
                
                if (!this.gameRunning) return;
                
                if (event.code === 'Space') {
                    event.preventDefault();
                    if (!this.isJumping) {
                        this.isJumping = true;
                        this.jumpVelocity = 0.35;
                    }
                }
                
                if (event.code === 'ArrowLeft' && this.playerLane > 0) {
                    this.playerLane--;
                }
                if (event.code === 'ArrowRight' && this.playerLane < 2) {
                    this.playerLane++;
                }
            }
            
            handleKeyUp(event) {
                this.keys[event.code] = false;
            }
            
            onWindowResize() {
                if (this.camera && this.renderer) {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }
            
            initThreeJS() {
                const container = document.getElementById('gameContainer');
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 30, 150);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 6, 10);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFShadowMap;
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                container.appendChild(this.renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0x8A2BE2, 1.5);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);
                
                // Player
                const playerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const playerMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8A2BE2,
                    emissive: 0x4B0082,
                    shininess: 100
                });
                this.player = new THREE.Mesh(playerGeometry, playerMaterial);
                this.player.position.set(0, 1, 8);
                this.player.castShadow = true;
                this.scene.add(this.player);
                
                this.createTrack();
                this.createParticles();
                
                // Start render loop
                this.render();
            }
            
            createTrack() {
                for (let i = 0; i < 3; i++) {
                    const laneGeometry = new THREE.PlaneGeometry(2.5, 200);
                    const laneMaterial = new THREE.MeshLambertMaterial({
                        color: 0x1a1a2e,
                        transparent: true,
                        opacity: 0.7
                    });
                    const lane = new THREE.Mesh(laneGeometry, laneMaterial);
                    lane.rotation.x = -Math.PI / 2;
                    lane.position.set((i - 1) * 3, 0, -90);
                    lane.receiveShadow = true;
                    this.scene.add(lane);
                    
                    // Borders
                    const borderGeometry = new THREE.BoxGeometry(0.1, 0.3, 200);
                    const borderMaterial = new THREE.MeshLambertMaterial({
                        color: 0x00FFFF,
                        emissive: 0x008888
                    });
                    
                    const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                    leftBorder.position.set((i - 1) * 3 - 1.25, 0.15, -90);
                    this.scene.add(leftBorder);
                    
                    const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                    rightBorder.position.set((i - 1) * 3 + 1.25, 0.15, -90);
                    this.scene.add(rightBorder);
                }
            }
            
            createParticles() {
                const particleCount = 200;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 50;
                    positions[i * 3 + 1] = Math.random() * 30;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0xFF1493,
                    size: 0.2,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particleSystem = new THREE.Points(particles, particleMaterial);
                this.scene.add(particleSystem);
            }
            
            createObstacle(lane, distance, type = 'standard') {
                let obstacle;
                
                switch (type) {
                    case 'wall':
                        const wallGeometry = new THREE.BoxGeometry(2, 3, 0.5);
                        const wallMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFF0040,
                            emissive: 0x440011
                        });
                        obstacle = new THREE.Mesh(wallGeometry, wallMaterial);
                        break;
                    case 'spikes':
                        const spikesGeometry = new THREE.ConeGeometry(0.5, 2, 6);
                        const spikesMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFF8000,
                            emissive: 0x442200
                        });
                        obstacle = new THREE.Mesh(spikesGeometry, spikesMaterial);
                        break;
                    case 'laser':
                        const laserGeometry = new THREE.BoxGeometry(2, 0.2, 0.2);
                        const laserMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFF0000,
                            emissive: 0xFF0000,
                            transparent: true,
                            opacity: 0.8
                        });
                        obstacle = new THREE.Mesh(laserGeometry, laserMaterial);
                        obstacle.position.y = 1.5;
                        break;
                    default:
                        const obstacleGeometry = new THREE.BoxGeometry(1.5, 2, 1);
                        const obstacleMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFF0080,
                            emissive: 0x330033
                        });
                        obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                }
                
                obstacle.position.set((lane - 1) * 3, type === 'laser' ? 1.5 : 1, -distance);
                obstacle.castShadow = true;
                this.scene.add(obstacle);
                this.obstacles.push({ mesh: obstacle, lane, type });
            }
            
            createCollectible(lane, distance) {
                const collectibleGeometry = new THREE.OctahedronGeometry(0.4, 0);
                const collectibleMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00FF00,
                    emissive: 0x004400
                });
                const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
                collectible.position.set((lane - 1) * 3, 1.5, -distance);
                collectible.castShadow = true;
                this.scene.add(collectible);
                this.collectibles.push({ mesh: collectible, lane });
            }
            
            createPowerUp(lane, distance, type) {
                let color, emissive;
                
                switch (type) {
                    case 'shield':
                        color = 0x0080FF;
                        emissive = 0x002244;
                        break;
                    case 'speed':
                        color = 0xFFFF00;
                        emissive = 0x444400;
                        break;
                    case 'breaker':
                        color = 0xFF4000;
                        emissive = 0x441100;
                        break;
                }
                
                const powerUpGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 6);
                const powerUpMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: emissive
                });
                const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
                powerUp.position.set((lane - 1) * 3, 1, -distance);
                powerUp.castShadow = true;
                this.scene.add(powerUp);
                this.powerUps.push({ mesh: powerUp, lane, type });
            }
            
            activatePowerUp(type) {
                this.activePowerUp = type;
                this.powerUpTimer = 5000;
                this.updatePowerUpUI();
            }
            
            checkCollisions() {
                const playerBoundingBox = new THREE.Box3().setFromObject(this.player);
                
                // Obstacles
                this.obstacles.forEach((obstacle, index) => {
                    if (obstacle.lane === this.playerLane) {
                        const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacle.mesh);
                        const collision = playerBoundingBox.intersectsBox(obstacleBoundingBox);
                        
                        if (collision) {
                            const canJumpOver = obstacle.type === 'laser' && this.isJumping && this.jumpHeight > 1;
                            const hasShield = this.activePowerUp === 'shield';
                            const canBreak = this.activePowerUp === 'breaker';
                            
                            if (!canJumpOver && !hasShield && !canBreak) {
                                this.gameOver();
                            } else if (canBreak) {
                                this.scene.remove(obstacle.mesh);
                                this.obstacles.splice(index, 1);
                                this.score += 5;
                            }
                        }
                    }
                });
                
                // Collectibles
                this.collectibles.forEach((collectible, index) => {
                    if (collectible.lane === this.playerLane) {
                        const collectibleBoundingBox = new THREE.Box3().setFromObject(collectible.mesh);
                        if (playerBoundingBox.intersectsBox(collectibleBoundingBox)) {
                            this.scene.remove(collectible.mesh);
                            this.collectibles.splice(index, 1);
                            this.score += 10;
                        }
                    }
                });
                
                // Power-ups
                this.powerUps.forEach((powerUp, index) => {
                    if (powerUp.lane === this.playerLane) {
                        const powerUpBoundingBox = new THREE.Box3().setFromObject(powerUp.mesh);
                        if (playerBoundingBox.intersectsBox(powerUpBoundingBox)) {
                            this.scene.remove(powerUp.mesh);
                            this.powerUps.splice(index, 1);
                            this.activatePowerUp(powerUp.type);
                            this.score += 20;
                        }
                    }
                });
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // Player movement
                const targetX = (this.playerLane - 1) * 3;
                this.player.position.x = THREE.MathUtils.lerp(this.player.position.x, targetX, 0.15);
                
                // Jumping
                if (this.isJumping) {
                    this.jumpHeight += this.jumpVelocity;
                    this.jumpVelocity -= 0.025;
                    this.player.position.y = 1 + Math.max(0, this.jumpHeight);
                    
                    if (this.jumpHeight <= 0) {
                        this.isJumping = false;
                        this.jumpHeight = 0;
                        this.player.position.y = 1;
                    }
                }
                
                // Speed increase
                const speedMultiplier = this.activePowerUp === 'speed' ? 2 : 1;
                this.gameSpeed += 0.001 * speedMultiplier;
                this.distance += this.gameSpeed;
                
                // Power-up timer
                if (this.powerUpTimer > 0) {
                    this.powerUpTimer -= deltaTime;
                    if (this.powerUpTimer <= 0) {
                        this.activePowerUp = null;
                        this.hidePowerUpUI();
                    }
                    this.updatePowerUpUI();
                }
                
                // Move objects
                const moveSpeed = this.gameSpeed * 3;
                
                [...this.obstacles, ...this.collectibles, ...this.powerUps].forEach((obj) => {
                    obj.mesh.position.z += moveSpeed;
                    if (obj.mesh.position.z > 15) {
                        this.scene.remove(obj.mesh);
                        if (this.obstacles.includes(obj)) {
                            this.obstacles.splice(this.obstacles.indexOf(obj), 1);
                        } else if (this.collectibles.includes(obj)) {
                            this.collectibles.splice(this.collectibles.indexOf(obj), 1);
                        } else if (this.powerUps.includes(obj)) {
                            this.powerUps.splice(this.powerUps.indexOf(obj), 1);
                        }
                    }
                });
                
                // Animate collectibles
                this.collectibles.forEach(collectible => {
                    collectible.mesh.rotation.y += 0.05;
                    collectible.mesh.rotation.x += 0.03;
                });
                
                this.powerUps.forEach(powerUp => {
                    powerUp.mesh.rotation.y += 0.1;
                    powerUp.mesh.position.y = 1 + Math.sin(currentTime * 0.005) * 0.2;
                });
                
                // Spawn objects
                this.spawnTimer += deltaTime;
                if (this.spawnTimer > Math.max(300, 1000 - this.gameSpeed * 100)) {
                    this.spawnTimer = 0;
                    
                    const lane = Math.floor(Math.random() * 3);
                    const random = Math.random();
                    
                    if (random < 0.6) {
                        const obstacleTypes = ['standard', 'wall', 'spikes', 'laser'];
                        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                        this.createObstacle(lane, 50, type);
                    } else if (random < 0.85) {
                        this.createCollectible(lane, 55);
                    } else {
                        const powerUpTypes = ['shield', 'speed', 'breaker'];
                        const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                        this.createPowerUp(lane, 60, type);
                    }
                }
                
                this.checkCollisions();
                this.updateGameUI();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            render() {
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.render());
            }
            
            startGame() {
                if (!this.playerName) return;
                
                this.gameRunning = true;
                this.gameSpeed = 0.5;
                this.score = 0;
                this.distance = 0;
                this.playerLane = 1;
                this.activePowerUp = null;
                this.powerUpTimer = 0;
                this.player.position.set(0, 1, 8);
                
                // Clear objects
                [...this.obstacles, ...this.collectibles, ...this.powerUps].forEach(obj => {
                    this.scene.remove(obj.mesh);
                });
                this.obstacles = [];
                this.collectibles = [];
                this.powerUps = [];
                
                this.hideAllMenus();
                this.showGameUI();
                this.hidePowerUpUI();
                
                this.lastTime = performance.now();
                this.gameLoop(this.lastTime);
            }
            
            gameOver() {
                this.gameRunning = false;
                if (this.playerName) {
                    this.saveScore(this.playerName, this.score, Math.floor(this.distance));
                }
                this.showGameOverScreen();
            }
            
            // UI Methods
            hideAllMenus() {
                document.getElementById('menuScreen').classList.add('hidden');
                document.getElementById('nameInput').classList.add('hidden');
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('gameOver').classList.add('hidden');
                document.getElementById('leaderboardScreen').classList.add('hidden');
            }
            
            showNameInput() {
                this.hideAllMenus();
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('nameInput').classList.remove('hidden');
                document.getElementById('playerName').value = this.playerName;
                document.getElementById('playerName').focus();
            }
            
            showMainMenu() {
                this.hideAllMenus();
                this.hideGameUI();
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('mainMenu').classList.remove('hidden');
                document.getElementById('welcomeName').textContent = this.playerName;
            }
            
            showGameOverScreen() {
                this.hideGameUI();
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('gameOver').classList.remove('hidden');
                document.getElementById('gameOverPlayer').textContent = this.playerName;
                document.getElementById('gameOverScore').textContent = this.score;
                document.getElementById('gameOverDistance').textContent = Math.floor(this.distance);
            }
            
            showLeaderboard() {
                this.hideAllMenus();
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('leaderboardScreen').classList.remove('hidden');
                this.updateLeaderboardDisplay();
            }
            
            showGameUI() {
                document.getElementById('gameUI').classList.remove('hidden');
                document.getElementById('playerDisplay').textContent = this.playerName;
            }
            
            hideGameUI() {
                document.getElementById('gameUI').classList.add('hidden');
            }
            
            updateGameUI() {
                document.getElementById('scoreDisplay').textContent = this.score;
                document.getElementById('distanceDisplay').textContent = Math.floor(this.distance);
                document.getElementById('speedDisplay').textContent = (5 + this.gameSpeed * 10).toFixed(1);
            }
            
            updatePowerUpUI() {
                if (this.activePowerUp && this.powerUpTimer > 0) {
                    document.getElementById('powerUpUI').classList.remove('hidden');
                    document.getElementById('powerUpName').textContent = this.powerUpNames[this.activePowerUp];
                    document.getElementById('powerUpTime').textContent = Math.ceil(this.powerUpTimer / 1000);
                }
            }
            
            hidePowerUpUI() {
                document.getElementById('powerUpUI').classList.add('hidden');
            }
            
            updateLeaderboardDisplay() {
                const list = document.getElementById('leaderboardList');
                if (this.leaderboard.length === 0) {
                    list.innerHTML = '<div class="text-gray">–†–µ–∫–æ—Ä–¥–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</div>';
                } else {
                    list.innerHTML = this.leaderboard.map((player, index) => `
                        <div class="leaderboard-entry">
                            <span class="text-yellow">#${index + 1}</span>
                            <span class="text-white" style="flex: 1; margin: 0 15px; text-align: left;">${player.name}</span>
                            <span class="text-green">${player.score}</span>
                            <span class="text-blue" style="margin-left: 10px; font-size: 12px;">${player.distance}m</span>
                        </div>
                    `).join('');
                }
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new NeonDriftGame();
        });
    </script>
</body>
</html>
